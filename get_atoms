#!/usr/bin/env python3
import argparse
from typing import List, Dict, Any, Set, Tuple

# Backbone atom names; anything else in a standard amino acid is considered sidechain
BB_NAMES = {"N", "CA", "C", "O", "OXT", "OT1", "OT2", "H", "HA"}
# GLY is not in the list. It doesn't have any sidechain, so fuck it!
AA_NAMES = { "ALA", "ARG", "ASN", "ASP", "CYS", "GLN", "GLU", "HIS", "ILE", "LEU", "LYS", "MET", "PHE", "PRO", "SER", "THR", "TRP", "TYR", "VAL", "ASH", "GLH", "HIE", "HSE", "HIP", "HSP", "HID", "HSD", "LYN", "CYX", "CYM" }
WATERS = {"HOH", "WAT", "H2O", "DOD"}


def readPDB(path: str) -> List[Dict[str, Any]]:
    atoms: List[Dict[str, Any]] = []
    with open(path) as pdb:
        for line in pdb:
            if not (line.startswith("ATOM") or line.startswith("HETATM")):
                continue
            record = line[0:6].strip()
            try:
                serial = int(line[6:11])
            except ValueError:
                continue
            name = line[12:16].strip()
            altloc = line[16].strip()
            resname = line[17:20].strip()
            chain = line[21].strip()
            resseq_str = line[22:26].strip()
            icode = line[26].strip()
            try:
                resseq = int(resseq_str)
            except ValueError:
                # this fucks up sometimes
                continue
            try:
                x = float(line[30:38])
                y = float(line[38:46])
                z = float(line[46:54])
            except ValueError:
                continue

            if altloc not in ("", " ", "A"):
                continue

            atoms.append({"index": len(atoms),"serial": serial,"name": name, "resname": resname, "chain": chain,"resseq": resseq,"icode": icode,"x": x,"y": y,"z": z,"record": record})
    return atoms


def is_sidechain(atom: Dict[str, Any]) -> bool:
    if atom["record"] != "ATOM":
        return False
    if atom["resname"] not in AA_NAMES:
        return False
    if atom["name"] in BB_NAMES:
        return False
    return True


def is_water(atom: Dict[str, Any]) -> bool:
    return atom["resname"] in WATERS


def is_other(atom: Dict[str, Any]) -> bool:
    return atom["record"] == "HETATM"


def residue_key(atom: Dict[str, Any]) -> Tuple[str, int, str, str]:
    return (atom["chain"], atom["resseq"], atom["icode"], atom["resname"])


def find_neighbors(
    atoms: List[Dict[str, Any]],
    residue_numbers: Set[int],
    cutoff: float,
) -> List[int]:
    central_indices = [
        a["index"] for a in atoms if a["resseq"] in residue_numbers
    ]
    if not central_indices:
        return []

    coords = [(a["x"], a["y"], a["z"]) for a in atoms]
    central_coords = [coords[i] for i in central_indices]

    neighbor_residues: Set[Tuple[str, int, str, str]] = set()

    for atom in atoms:
        if atom["resseq"] in residue_numbers:
            continue

        if not (is_sidechain(atom) or is_water(atom) or is_other(atom)):
            continue

        key = residue_key(atom)
        if key in neighbor_residues:
            # already marked; no need to re-check distances
            continue

        x, y, z = coords[atom["index"]]

        for (cx, cy, cz) in central_coords:
            dx = x - cx
            dy = y - cy
            dz = z - cz
            if dx * dx + dy * dy + dz * dz <= cutoff**2:
                neighbor_residues.add(key)
                break

    neighbor_indices: Set[int] = set()
    for atom in atoms:
        if atom["resseq"] in residue_numbers:
            continue
        if not (is_sidechain(atom) or is_water(atom) or is_other(atom)):
            continue
        if residue_key(atom) in neighbor_residues:
            neighbor_indices.add(atom["index"])

    return sorted(neighbor_indices)


def squeeze_list(indices: List[int]) -> str:
    if not indices:
        return ""

    indices = sorted(indices)
    ranges = []
    start = prev = indices[0]

    for x in indices[1:]:
        if x == prev + 1:
            prev = x
        else:
            if start == prev:
                ranges.append(str(start))
            else:
                ranges.append(f"{start}-{prev}")
            start = prev = x

    # flush last range
    if start == prev:
        ranges.append(str(start))
    else:
        ranges.append(f"{start}-{prev}")

    return ",".join(ranges)


def main():
    parser = argparse.ArgumentParser(
        description=(
            "Prints atom indices of sidechain/waters/ligands that have at least one atom within a given distance of specified residue(s) in a PDB file. "
        )
    )
    parser.add_argument(
        "-p", "--pdb", required=True, help="PDB filename"
    )
    parser.add_argument(
        "-r",
        "--residues",
        required=True,
        nargs="+",
        type=int,
        help="Residue number(s)",
    )
    parser.add_argument(
        "-d",
        "--distance",
        required=True,
        type=float,
        help="Cutoff distance (A)",
    )
    parser.add_argument(
        "-z",
        "--zero",
        action="store_true",
        help="Start atom indices from 0 instead of 1 (For Orca)",
    )

    args = parser.parse_args()

    atoms = readPDB(args.pdb)
    if not atoms:
        return

    residue_numbers = set(args.residues)
    neighbor_indices_0 = find_neighbors(atoms, residue_numbers, args.distance)

    if args.zero:
        output_indices = neighbor_indices_0
    else:
        output_indices = [i + 1 for i in neighbor_indices_0]

    formatted = squeeze_list(output_indices)
    print(formatted)


if __name__ == "__main__":
    main()

